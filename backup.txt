 /* Compiles a simple language into the SML code that was made in the prior project
 * On my honor, I have neither given nor received unuauthorized assistance on this assignment.
 * Author: Buchmaier Coble Daniel Wolfgang
 */
#include <iostream>
#include <string>
#include <iomanip>
#include <array>
#include <string>
#include <vector>
#include <fstream>
#include <sstream>
#include <cctype>
#include <algorithm>
using namespace std;
//takes in varname or integer (ex 2215) and returns the location in final memory
string returnvarlocation(string varname, vector<array<string, 2>>&variablelist){
  if(variablelist.size()>0){
    string simpleloc = "";
    for(array<string, 2> pair : variablelist){
      if(pair[1]==varname){
        simpleloc = pair[0];
      }
    }
    if(simpleloc!=""){
      return simpleloc;
    }else{
      int locoflastvariable; istringstream(variablelist[variablelist.size()-1][0]) >> locoflastvariable; 
      if(locoflastvariable<10){
        variablelist.push_back( {"0"+to_string(locoflastvariable-1), varname} ); 
      }else{
        variablelist.push_back( {to_string(locoflastvariable-1), varname} );
      }
      
      return to_string(variablelist.size()-1);
    }
  }else{
    variablelist.push_back({"99",  varname});
    return returnvarlocation(varname, variablelist);
  }
}
/* a helper method for parseExpression */
int precedence(string c) {
  if(c == "^") {return 3;}
  else if (c == "*" || c == "/") {return 2;}
  else if (c == "+" || c == "-") {return 1;}
  else {return -1;}
}
/* this method parses expressions. it adds directly to the memory, and returns the 
 * memory location where the final parsed expression will be stored*/
string parseExpression(vector<string> infix, string simpleline, int memstart, vector<array<string, 2>>& variablelist, vector<array<string, 2>>&linelist){
  //if infix is just one term, variable or literal, then we just return the value of that location batta bing batta boom. 
  if(infix.size() == 1) {return returnvarlocation(infix[0], variablelist);}
  //this code was for when the original expression was a string, and changing it to a vector<string>. no longer necessary.
  /*vector<string> infix;
  string word = "";
  for(char c : expression) {
    if(c != ' ') {
      word += c;
    }
    else {
      infix.push_back(word);
      word = "";
    }
  }
  infix.push_back(word);*/
  //all the below does is change expression to the postfix notation string postfix.
  vector<string> stack;
  int l = infix.size();
  string postfix;
  for(int i = 0; i < l; i++) {
    if(precedence(infix[i]) == -1 && infix[i] != "(" && infix[i] != ")"){
      postfix += infix[i] + " ";
    }
    else if(infix[i] == "(") {
      stack.insert(stack.begin(), "(");    }
    else if(infix[i] == ")") {
      while(stack.size() != 0 && stack[0] != "(") { 
        string c = stack[0]; 
        stack.erase(stack.begin());
        postfix += c + " "; 
      } 
      if(stack[0] == "(") { 
        string c = stack[0];
        stack.erase(stack.begin());
      }
    }
    else{
      while(stack.size() != 0 && precedence(infix[i]) <= precedence(stack[0])) {
        string c = stack[0];
        stack.erase(stack.begin());
        postfix += c + " "; 
      } 
      stack.insert(stack.begin(), infix[i]); 
    } 
  }
  while(stack.size() != 0) { 
    string c = stack[0]; 
    stack.erase(stack.begin());
    postfix += c + " "; 
  }
  //there may be some number of spaces at the end of postfix
  while(postfix.at(postfix.size() - 1) == ' ') {
    postfix = postfix.substr(0, postfix.size() - 1);
  }
  /*now we take the string and break it back into a word across spaces.
  * why convert it to string then back to vector? it was a by-product of
  * how i wrote this code in a non-linear order.*/
  vector<string> postfixed;
  string word = "";
  for(char c : postfix) {
    if(c != ' ') {
      word += c;
    }
    else {
      postfixed.push_back(word);
      word = "";
    }
  }
  postfixed.push_back(word);
  //this is the vector of machine lines that will be added at the end of this code.
  vector<string> machinelines;
  int memcurrent = memstart;
  while(postfixed.size() > 1) {
    int i = 0;
    while(precedence(postfixed[i]) == -1) {i++;}
    string var1 = postfixed[i - 2];
    string var2 = postfixed[i - 1];
    string var1loc, var2loc;
    if(var1.at(0) == 'X') {var1loc = var1.substr(1);}
    else {var1loc = returnvarlocation(var1, variablelist);}
    if(var2.at(0) == 'X') {var2loc = var2.substr(1);}
    else {var2loc = returnvarlocation(var2, variablelist);}
    if(var1loc.size() == 1) {var1loc = "0" + var1loc;}
    if(var2loc.size() == 1) {var2loc = "0" + var2loc;}
    machinelines.push_back("20" + var1loc);
    if(postfixed[i] == "+") {machinelines.push_back("30" + var2loc);}
    else if(postfixed[i] == "-") {machinelines.push_back("31" + var2loc);}
    else if(postfixed[i] == "/") {machinelines.push_back("32" + var2loc);}
    else if(postfixed[i] == "*") {machinelines.push_back("33" + var2loc);}
    string smemcurrent = to_string(memcurrent);
    if(smemcurrent.size() == 1) {smemcurrent = "0" + smemcurrent;}
    machinelines.push_back("21" + to_string(memcurrent));
    postfixed.erase(postfixed.begin() + i - 2);
    postfixed.erase(postfixed.begin() + i - 2);
    postfixed.erase(postfixed.begin() + i - 2);
    postfixed.insert(postfixed.begin() + i - 2, "X" + to_string(memcurrent));
    memcurrent --;
  }
  //append machinelines onto linelist
  for(string i : machinelines) {
    linelist.push_back({simpleline, i});
  }
  return postfixed[0].substr(1);
}

/* takes in a paresed line with simpleline number cut out and spits out a or a few lines of machine code*/
//variable list is {(locationinfinalcode, variable name), (..)}  numbers will just be final variables
//linelist is {(simplelinenumber, 2215), (...)}
void parseCommand(string simpleline, int memstart, vector<string> parsedline, vector<array<string, 2>>& variablelist, vector<array<string, 2>>&linelist) {
  if(parsedline[0] == "if"){
    //find operator
    int operatorlocation;
    int iftruelocation;
    int i = 0;
    for(string element : parsedline){
      if(element == "==" || element =="<" || element ==">"){operatorlocation=i;}
      else if(i>0 && (element == "if" || element == "goto" || element == "let" || element == "input" || element == "print" || element == "end"/* || element == "rem"*/)){iftruelocation=i; break;}
      i++;
    }

    //further parse the parsedline vector into if statement components
    
    vector<string> firsthalf (parsedline.begin()+1, parsedline.begin()+operatorlocation);
    
    string compare1 = parseExpression(firsthalf, simpleline, memstart, variablelist, linelist);
    string compareoperator = parsedline[operatorlocation];
    cout<<compareoperator<<endl;
    vector<string> lasthalf (parsedline.begin()+operatorlocation+1, parsedline.begin()+iftruelocation);
    string compare2 = parseExpression(lasthalf, simpleline, memstart, variablelist, linelist);
    
    //check for numbers to add to variable list
    vector<string> parsediftrue (parsedline.begin()+iftruelocation, parsedline.end());

    //if elvaluation
    if (compareoperator == "=="){//3 cases
      linelist.push_back({simpleline, "30"+compare1});//put in first half
      linelist.push_back({simpleline, "31"+compare2});//subtract by second half
      int branchcommandlocation = linelist.size();
      linelist.push_back({simpleline, "41"});//skip code if comepare2>compare1
      linelist.push_back({simpleline, "30"+compare2});//put in first half
      linelist.push_back({simpleline, "31"+compare1});//subtract by second half
      linelist.push_back({simpleline, "41"});//skip code if comepare1>compare2

      parseCommand(simpleline, memstart, parsediftrue, variablelist, linelist);
      int endbranchlocation = linelist.size();
      if(endbranchlocation<10){
        linelist[branchcommandlocation][1] += "0"+to_string(endbranchlocation);
        linelist[branchcommandlocation+3][1] += "0"+to_string(endbranchlocation);
      }else{
        linelist[branchcommandlocation][1] += endbranchlocation;
        linelist[branchcommandlocation+3][1] += endbranchlocation;
      }
    }else if(compareoperator == "<"){
      linelist.push_back({simpleline, "30"+compare2});//put in first half
      linelist.push_back({simpleline, "31"+compare1});//subtract by second half
      int branchcommandlocation = linelist.size();
      linelist.push_back({simpleline, "41"});//skip code if comepare1>compare2

      parseCommand(simpleline, memstart, parsediftrue, variablelist, linelist);
      int endbranchlocation = linelist.size();
      if(endbranchlocation<10){linelist[branchcommandlocation][1] += "0"+to_string(endbranchlocation);}
      else{linelist[branchcommandlocation][1] += endbranchlocation;}
    }else if(compareoperator == ">"){
      linelist.push_back({simpleline, "30"+compare1});//put in first half
      linelist.push_back({simpleline, "31"+compare2});//subtract by second half
      int branchcommandlocation = linelist.size();
      linelist.push_back({simpleline, "41"});//skip code if compare1<comepare2

      parseCommand(simpleline, memstart, parsediftrue, variablelist, linelist);
      int endbranchlocation = linelist.size();
      if(endbranchlocation<10){linelist[branchcommandlocation][1] += "0"+ to_string(endbranchlocation);}
      else{linelist[branchcommandlocation][1] += endbranchlocation;}
    }
  }else if(parsedline[0] == "let"){
    string location;
    for(array<string, 2> pair : variablelist){
      if(pair[1] == parsedline[1]){location = pair[0]; break;}
    }
    vector<string> expression (parsedline.begin()+3, parsedline.end());
    linelist.push_back({simpleline, "20"+parseExpression(expression, simpleline, memstart, variablelist, linelist)});
    linelist.push_back({simpleline, "21"+location});
    
  }else if(parsedline[0] == "goto"){
    string location;
    int i = 0;
    for(array<string, 2> pair : linelist){
      //cout<<parsedline[1]<<" "<<pair[0]<<endl;
      if(parsedline[1] == pair[0]){
        if(i<10){location = "0"+to_string(i); break;}
        else{location = to_string(i); break;}
      }
      i++;
    }
    //cout<<"location: "<<location<<endl;
    linelist.push_back({simpleline, "40"+location});
  }else if(parsedline[0] == "rem"){//primary
    //do nothing
  }else if(parsedline[0] == "input"){//primary
    linelist.push_back( {simpleline, "10"+ returnvarlocation(parsedline[1], variablelist)} );
  }else if(parsedline[0] == "print"){//primary
    linelist.push_back( {simpleline, "11"+ returnvarlocation(parsedline[1], variablelist)} );
  }else if(parsedline[0] == "end"){//primary
    linelist.push_back( {simpleline, "4300"} );
  }
}


int main() {
	//1 pulls in lines and turns them into an array
  vector<string> lines (0);
  ifstream infile("zSimpleExample.txt", ios::in);
	string next;
	while(getline(infile, next)) {
		lines.push_back(next);
	}
	infile.close();

  //2 splitting the lines into a 2D vector around ' '
  vector<vector<string>> parsedlines;
  for(string line : lines){
    vector<string> parsedline;
    string lastword = "";
    for(char c : line){
      if(c != ' '){lastword+=c;}
      else{
        parsedline.push_back(lastword);
        lastword = "";
      }
    }
    parsedline.push_back(lastword);
    
    parsedlines.push_back(parsedline);
  }//should now have { {40, let, i, =, 0}, {...}, ...}
  

  //3 preloading variables and literals into variable list, exclude rem, goto
  //plan: if an expression has more than 1 operation we will need fake variables
  //these fake variables will be stored right after real variabels
  //literals will need to be in memory before code can even run, not in machine code though

  vector<array<string, 2>> variablelist; //varibale list will be {(memorylocation, variable name), (..)}
  vector<array<string, 2>> linelist; //linelist will be {(simplelinenumber, 2215), (...)}

  for(vector<string> line : parsedlines){
    line.erase(line.begin());
    for(string element : line){
      if(element == "goto" || element == "rem"){break;}
      else if(element == "a" || element == "b" || element == "c" || element == "d" || element == "e" || element == "f" || element == "g" || element == "h" || element == "i" || element == "j" || element == "k" || element == "l" || element == "m" || element == "n" || element == "o" || element == "p" || element == "q" || element == "r" || element == "s" || element == "t" || element == "u" || element == "v" || element == "w" || element == "x" || element == "y" || element == "z" || isdigit(element[0]) || (element[0] == '-' && isdigit(element[1]) ) ){
        returnvarlocation(element, variablelist);
      }
    }
  }
  int freememorystart; istringstream(variablelist[variablelist.size()-1][0]) >> freememorystart; freememorystart-=1;

  for(array<string, 2> pair : variablelist){
    cout<<pair[0]<<"\t"<<pair[1]<<endl;
  }
  
  //4 creating list of code lines and variables and number locations kept track of
  
  for(vector<string> parsedline : parsedlines){
    string simpleline = parsedline[0];
    parsedline.erase(parsedline.begin());
    parseCommand(simpleline, freememorystart, parsedline, variablelist, linelist);
  }

  int i = 0;
  for(array<string, 2> line : linelist) {
    if(line[1] == "40") {

    }
    i++;
  }
  //5 pushes out lines into text document
  ofstream outfile("outputMachine.txt", ios::out);
  int i = 0;
	for(array<string, 2> line : linelist){
    outfile << line[1] << endl;
    i++;
  }
  int firstvar; istringstream(variablelist[variablelist.size()-1][0]) >> firstvar;
  while(i<firstvar){outfile << "0000" << endl; i++;}
  reverse(variablelist.begin(), variablelist.end());
  for(array<string, 2> pair : variablelist){
    if(isdigit(pair[1][0]) || (pair[1][0] == '-' && isdigit(pair[1][0]) )){
      string out;
      string literal = pair[1];
      if(literal.size()==1){out = "000"+literal;}
      else if(literal.size()==2){out = "00"+literal;}
      else if(literal.size()==3){out = "0"+literal;}
      else if(literal.size()==4){out = literal;}
      outfile << out << endl;
    }
    else{outfile << "0000" << endl;}
  }
  reverse(variablelist.begin(), variablelist.end());
	outfile.close();
}